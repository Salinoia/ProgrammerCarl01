## 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示**一支**给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 示例 1：
- 输入：[7,1,5,3,6,4]
- 输出：5
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
- 示例 2：
- 输入：prices = [7,6,4,3,1]
- 输出：0
- 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

​	本题的关键是**股票只能买卖一次**；

​	动规五部曲：
​	1.确定dp数组下标及其含义
​	每天其实就是两种状态，手里有股票和手里没股票，再加上“某天”这个维度，所以用一个二维的就可以表示所有天数的情况。dp数组有i行，i就是天数。有两列，表示某一天的两种情况。
​	dp\[i][0]表示，第i天手里持有股票的状态下的最大利润；

​	**这里持有的这个股票有两种情况，**

​	**1.前面一直没买过股票，买了第i天这个股票；**

​	**2.第i天之前的某一天已经买了一个股票，一直没卖，一直持有到第i天**；

​	dp\[i][1]表示，第i天手里不持有股票状态的最大利润；

​	**这里的不持有股票有三种情况：**

​	**1.从第0天到第i天，一直没买过股票**；

​	**2.是第i天之前的某一天买过股票，在第i天卖掉**；

​	**3.是在第i天之前已经有过一次买股票和一次卖股票的操作了所以在第i天是不持有股票的状态**

​	如果仅仅定义为买入和卖出两种状态，就需要额外定义保持买入和保持卖出的定义，这样定义是无法通过二维数组实现的；

​	2.递推公式的推导：

```cpp
	dp[i][0] = max(dp[i - 1][0],  -prices[i]);//因为只允许股票购入一次，所以此处直接取-price[i]，因为只买卖一次
	dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
```

​	3.初始化

​	由于递推公式中dp[i]都是由dp[i - 1]推出，所以直接给出初始化：

```cpp
	dp[0][0] = -price[0];
	dp[0][1] = 0;
```

​	4.遍历顺序

​	由于只需要满足从前往后的遍历，所以直接写就行了

​	5.打印dp数组

![](https://gitee.com/salinoia/image/raw/master/20210224225642465.png)

```cpp
    class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            int len = prices.size();
            if(len == 0)  return 0;
            vector<vector<int>> dp(len, vector<int>(2));
            dp[0][0] = -prices[0];
            dp[0][1] = 0;
            for(int i = 1; i < len; i++){
                dp[i][0] = max(dp[i - 1][0], -prices[i]);
                dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            }
            return dp[len - 1][1];
        }
    };
```

## 买卖股票的最佳时机Ⅱ

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例 1:
- 输入: [7,1,5,3,6,4]
- 输出: 7
  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
- 示例 2:
- 输入: [1,2,3,4,5]
- 输出: 4
  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
- 示例 3:
- 输入: [7,6,4,3,1]
- 输出: 0
  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

提示：

- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4

​	**可多次买卖操作，但必须先售出之前买的再买**；

​	思路和上题大致是一致的，只有在递推公式上有小的区别，因为购入操作之前的本金不一定是零；

```cpp
	dp[i][0] = max(dp[i- 1][0], dp[i - 1][1] - prices[i]);
	dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
```

​	代码如下

```cpp
    class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            int len = prices.size();
            if(len == 0)  return 0;
            vector<vector<int>> dp(len, vector<int>(2));
            dp[0][0] = -prices[0];
            dp[0][1] = 0;
            for(int i = 1; i < len; i++){
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]-prices[i]);
                dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
            }
            return dp[len - 1][1];
        }
    };
```

