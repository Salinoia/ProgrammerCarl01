## 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。

示例 1:

- 输入: "()"
- 输出: true

示例 2:

- 输入: "()[]{}"
- 输出: true

示例 3:

- 输入: "(]"
- 输出: false

示例 4:

- 输入: "([)]"
- 输出: false

示例 5:

- 输入: "{[]}"

- 输出: true

  ​	只有三种场景下字符串失效：出现多余的左括号、左右括号不匹配、出现多余的右括号；

  ​	那么思路就是，遍历整个字符串，将所有的左括号丢进栈1，把所有的右括号丢进栈2，然后同时pop栈1栈2，看pop出的元素是否匹配，若存在不匹配或者栈提前延后判空的情况，则return false；看了卡哥的讲解，发现实际上不需要栈1，只要遍历到左括号，就直接将对应的右括号push进栈中，然后再依次pop元素看是否与字符串中的右括号匹配即可；

  考虑三种异常匹配情况：

​	第一种情况（延后判空）：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

​	第二种情况（不匹配）：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

​	第三种情况（提前判空）：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

​	整体代码如下：

```c++
class Solution {
public:
    //stack<int> st;    其实两种表达形式都可以，因为字符是以ASCII码的形式存储的
    stack<char> st;
    bool isValid(string s) {
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '{')    st.push('}');
            else if(s[i] == '[')    st.push(']');
            else if(s[i] == '(')    st.push(')');
            //else if(st.top() != s[i] || st.empty())   不能操作空栈
            else if(st.empty() || st.top() != s[i]) return false;//考虑二三种情况
            // 第三种情况：遍历字符串匹配的过程中，栈提前判空了，没有匹配的字符了 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else st.pop();
        }
        //第一种情况：遍历完整个字符串后，栈还未判空，则st.empty()直接return false,否则不存在任何异常return true
        return st.empty();
    }
};
```

## 删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：

- 输入："abbaca"
- 输出："ca"
- 解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

提示：

- 1 <= S.length <= 20000

- S 仅由小写英文字母组成

  ​	和有效括号的思路是一致的，判断栈中是否为空或者元素是否重复元素，然后将元素存进栈中，若读取到相同元素则pop，直到将所有的字符都存进栈中，然后将栈中的元素存储到res字符串中再reverse即可

  ```c++
  class Solution {
  public:   
      string removeDuplicates(string S) {
          stack<char> st;
          for(char s:S){
              if(st.empty() || st.top() != s){
                  st.push(s);
              }
              else    st.pop();
          }
          string res = "";
          while(!(st.empty())){
              res += st.top();
              st.pop();          
          }
          reverse(res.begin(),res.end());
          return res;
      }
  };
  ```

  ​	还可以直接用字符串实现栈的功能以降低空间复杂度：

  ```c++
  class Solution {
  public:   
      string removeDuplicates(string S){//直接使用字符串作为栈
          string res;
          for(char s:S){
              if(res.empty() || res.back() != s){
                  res.push_back(s);
              }
              else res.pop_back();
          }
          return res;
      }
  };
  ```

## 逆波兰表达式

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：

- 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]

- 输出: 22

- 解释:该算式转化为常见的中缀算术表达式为：

  ```text
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5       
  = ((10 * (6 / (12 * -11))) + 17) + 5       
  = ((10 * (6 / -132)) + 17) + 5     
  = ((10 * 0) + 17) + 5     
  = (0 + 17) + 5    
  = 17 + 5    
  = 22    
  ```

逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

​	比较典型的题了，二叉树的后序遍历，左右中，想起了大二的时光了：

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 力扣修改了后台测试数据，需要用longlong
        stack<long long> st; 
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出,释放内存（其实不弹出也没事）
        return result;
    }
};
```