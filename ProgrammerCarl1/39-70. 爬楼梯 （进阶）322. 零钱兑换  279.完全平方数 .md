## 爬楼梯（进阶）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

输入描述：输入共一行，包含两个正整数，分别表示n, m

输出描述：输出一个整数，表示爬到楼顶的方法数。

输入示例：3 2

输出示例：3

提示：

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

- 1 阶 + 1 阶 + 1 阶段
- 1 阶 + 2 阶
- 2 阶 + 1 阶

​	这里有别于之前的爬楼梯问题，每次可以爬的楼梯数不再局限于1、2个台阶；

​	很容易转化为完全背包问题：
​	1阶，2阶，.... m阶就是物品（此时w和v数组的值都是阶数），楼顶就是背包；

​	每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶；

​	问跳到楼顶有几种方法其实就是问装满背包有几种方法；

​	动规五部曲：
​	1.确定dp数组以及下标的含义

​	**dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法**。

​	2.确定递推公式

​	求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];

​	本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]

​	那么递推公式为：dp[i] += dp[i - j]

​	3.dp数组如何初始化

​	既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。

​	下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果

​	4.确定遍历顺序

​	这是背包里求排列问题，即：**1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！**

​	所以需将target放在外循环，将nums放在内循环。

​	每一步可以走多次，这是完全背包，内循环需要从前向后遍历。

​	5.举例来推导dp数组

​	略；

```cpp
	#include <iostream>
	#include <vector>
	using namespace std;
	int main() {
    	int n, m;
    	while (cin >> n >> m) {
        	vector<int> dp(n + 1, 0);
        	dp[0] = 1;
        	for (int i = 1; i <= n; i++) { // 遍历背包
            	for (int j = 1; j <= m; j++) { // 遍历物品
                	if (i - j >= 0) dp[i] += dp[i - j];
            	}
        	}
        	cout << dp[n] << endl;
    	}
	}
```

## 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的**最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1：

- 输入：coins = [1, 2, 5], amount = 11
- 输出：3
- 解释：11 = 5 + 5 + 1

示例 2：

- 输入：coins = [2], amount = 3
- 输出：-1

示例 3：

- 输入：coins = [1], amount = 0
- 输出：0

示例 4：

- 输入：coins = [1], amount = 1
- 输出：1

示例 5：

- 输入：coins = [1], amount = 2
- 输出：2

提示：

- 1 <= coins.length <= 12
- 1 <= coins[i] <= 2^31 - 1
- 0 <= amount <= 10^4

​	完全背包，动规五部曲

​	1.dp数组含义：

​	dp[j]表示装满容量为j的背包需要的最少物品数为dp[j]；

​	2.递推公式：

​	dp[j] = min(dp[j], dp[j - coins[i]] +1);

​	3.初始化：

​	由题意可知，dp[0] = 0;由于题目需要min运算得到最小值，所以非零下标应该初始化为INT_MAX

​	4.遍历顺序：

​	由于求的只是元素数量，所以不需要考虑求组合或是排列的问题；

​	先遍历物品再遍历背包和先遍历背包再遍历物品都是可以的；

​	**很多时候，递推公式不难，但是遍历顺序很难理解**

​	5.打印数组：

![](https://gitee.com/salinoia/image/raw/master/20210201111833906.jpg)

```cpp
  int coinChange(vector<int>& coins, int amount){
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
  }
```

## 完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：

- 输入：n = 12
- 输出：3
- 解释：12 = 4 + 4 + 4

示例 2：

- 输入：n = 13
- 输出：2
- 解释：13 = 4 + 9

提示：

- 1 <= n <= 10^4

​	将题目转化为，给定一个容量为n的背包，用平方数填充，填充满背包所需要的最少平方和数量数为多少；

​	这样就和上题一致了，只是把上题的coins[i]改成了i*i；

​	即：

```cpp
	vector<int> dp(n + 1, INT_MAX);
	dp[0] = 0;
	for (int i = 0; i <= n; i++) { // 遍历背包
    	for (int j = 1; j * j <= i; j++) { // 遍历物品
        	dp[i] = min(dp[i - j * j] + 1, dp[i]);
    	}
	}
```

​	打印dp数组：
![](https://gitee.com/salinoia/image/raw/master/20210202112617341.jpg)

​	整体代码如下：

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) { // 遍历物品
            for (int j = i * i; j <= n; j++) { // 遍历背包
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```

