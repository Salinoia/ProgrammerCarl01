## 回溯理论基础

​	在递归中已经提到过了，回溯是递归的副产品，只要有递归就会有回溯；

​	**回溯法本质是穷举**，穷举所有可能，然后选出需要的答案，并不是什么高效的算法；

​	不高效但又不得不用，那只能是因为问题过于复杂，普通的代码逻辑无法实现；

​	回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

​	**所有回溯法的问题都可以抽象为树形结构！**

​	因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**；

​	递归就要有终止条件，所以构成的结构必然是一棵高度有限的树（N叉树）；

​	回溯函数的伪代码如下：

```cpp
	void backtracking(参数)//参数不是能够直接确定的，需要在完善函数的时候进一步确定
```

​	既然是树形结构，那么遍历树形结构一定要有终止条件；所以回溯也有要终止条件；什么时候达到终止条件：树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归；

```cpp
	if (终止条件) {
    存放结果;
    return;
	}
```

​	回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度，如下图所示：(注意此处取的恰好是集合数和节点数一致的情况，并不是说回溯算法使用场景就是最优解)

![](https://gitee.com/salinoia/image/raw/master/20210130173631174.png)

​	

```cpp
	for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
	}
```

​	总体来说，回溯函数的模板如下：

```cpp
	void backtracking(参数) {
    	if (终止条件) {
        	存放结果;
        	return;
    	}

    	for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        	处理节点;
        	backtracking(路径，选择列表); // 递归
        	回溯，撤销处理结果
    	}
	}
```

## 组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

**提示：**

- `1 <= n <= 20`
- `1 <= k <= n`

​	直观的写法就是for循环，当k比较小的时候还是好写的；

​	如果n为100，k为50呢，那就50层for循环，此时就会发现用for循环嵌套连暴力解法都写不出来；

​	**回溯法解决其实就是用递归来解决嵌套层数的问题，每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**；

​	抽象为树的结构来理解回溯：

![](https://gitee.com/salinoia/image/raw/master/20201123195223940.png)

​	这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取；

​	第一次取1，集合变为2，3，4 ，因为k为2，只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推；每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围；图中可以发现n相当于树的宽度，k相当于树的深度；

​	那么如何在这个树上遍历，然后收集到需要的结果集呢？

​	图中每次搜索到了叶子节点，就找到了一个结果；相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

​	回溯三部曲：

​	首先，回溯函数的参数和返回值：

​	定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合(其实不用也可以，但是函数参数会很麻烦)；

```cpp
	vector<vector<int>>	result;//存放结果集
	vector<int>	path;//存放满足条件的路径
```

​	函数参数，既然是集合n里面取k个数，那么n和k是两个int型的参数必然是有的；

​	然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历(集合就是[1,...,n] )；

​	这样操作可以避免重复出现；

​	其次，回溯函数的终止条件：

​	path这个数组的大小如果达到k，说明找到了一个子集大小为k的组合了，此时到达所谓的叶子节点；

​	在图中path存的就是根节点到叶子节点的路径，如图红色部分：

![](https://gitee.com/salinoia/image/raw/master/20201123195407907.png)

此时用result二维数组，把path保存起来，并终止本层递归。

所以终止条件代码如下：

```cpp
if (path.size() == k) {
    result.push_back(path);
    return;
}
```

​	最后，单层搜索的过程：

​	回溯法的搜索过程就是一个树型结构的遍历过程，如下图所示，for循环用来横向遍历，递归的过程是纵向遍历：

![](https://gitee.com/salinoia/image/raw/master/20201123195242899.png)

​	for循环每次从startIndex开始遍历，然后用path保存取到的节点i：

```cpp
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
```

​	整体代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n; i++) {
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        result.clear(); // 可以不写
        path.clear();   // 可以不写
        backtracking(n, k, 1);
        return result;
    }
};
```

