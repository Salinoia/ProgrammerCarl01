## 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：

- 输入：[5,5,5,10,20]
- 输出：true
- 解释：
  - 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
  - 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
  - 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
  - 由于所有客户都得到了正确的找零，所以我们输出 true。

示例 2：

- 输入：[5,5,10]
- 输出：true

示例 3：

- 输入：[10,10]
- 输出：false

示例 4：

- 输入：[5,5,10,10,20]
- 输出：false
- 解释：
  - 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
  - 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
  - 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
  - 由于不是每位顾客都得到了正确的找零，所以答案是 false。

提示：

- 0 <= bills.length <= 10000

- bills[i] 不是 5 就是 10 或是 20

  ​	由于给出的都是5、10、20，而柠檬水售价是5，所以面对顾客给出的金额一共有三种情况：

  ​	第一种：顾客给出5，不用找，直接入账，皆大欢喜；

  ​	第二种：顾客给出10，一张5拿来找零，10入账，若没有多余的5就return false;

  ​	第三种：顾客给出20，优先找零10+5，没有就3张5，再没有就return false;

  ​	如果一直没有return false,则return true;

  ​	这一眼看过去，好像也没贪心的思路啊……

  ​	其实贪心就在情况三，局部最优：遇到账单20，**优先消耗10，再消耗5**，完成本次找零。

  ​	全局最优：完成全部账单的找零；

  ```cpp
  class Solution {
  public:
      bool lemonadeChange(vector<int>& bills) {
          int five = 0, ten = 0/*, twenty = 0*/;
          for (int bill : bills) {
              // 情况一
              if (bill == 5) five++;
              // 情况二
              if (bill == 10) {
                  if (five <= 0) return false;
                  ten++;
                  five--;
              }
              // 情况三
              if (bill == 20) {
                  // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                  if (five > 0 && ten > 0) {//贪心
                      five--;
                      ten--;
                      //twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
                  } else if (five >= 3) {
                      five -= 3;
                      //twenty++; // 同理，这行代码也可以删了
                  } else return false;
              }
          }
          return true;
      }
  };
  ```

  ​	遇到感觉没有思路的题目，可以静下心来**把所有能遇到的情况分析一下**，只要分析到具体情况了，一下子就豁然开朗了；

  ​	如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。

## 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：

- 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
- 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
- 解释：
  - 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
  - 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
  - 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
  - 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
  - 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
  - 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

示例 2：

- 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
- 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

提示：

- 1 <= people.length <= 2000
- 0 <= hi <= 10^6
- 0 <= ki < people.length

题目数据确保队列可以被重建

​	和分发糖果类似，这种两个维度的问题不能直接一起考虑处理；

​	如果先按k的顺序排列的话，会发现排出来k也不对，h也不对；

​	所以考虑先排h，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面；

​	**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高**；

![](https://gitee.com/salinoia/image/raw/master/20201216201851982.png)

​	身高都是从小到大排列了，此时再根据k的值移动每一个元素即可，例如[6 1]我们就将其插入到新数组下标为1 的地方，[5 0]就插入到新数组下标为0的地方，以此类推；按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列；

​	**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**；

​	**全局最优：最后都做完插入操作，整个队列满足题目队列属性**；

​	排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

​	插入的过程：

- 插入[7,0]：[[7,0]]

- 插入[7,1]：[[7,0],[7,1]]

- 插入[6,1]：[[7,0],[6,1],[7,1]]

- 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]

- 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]

- 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

  使用新的队列的原因：直接在原有数组上进行变动可能会导致元素重复读取；

  ```cpp
  class Solution {
  public:
      static bool cmp(const vector<int>& a, const vector<int>& b) {
          if (a[0] == b[0]) return a[1] < b[1];
          return a[0] > b[0];
      }
      vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
          sort (people.begin(), people.end(), cmp);
          vector<vector<int>> que;
          for (int i = 0; i < people.size(); i++) {
              int position = people[i][1];//取k元素
              que.insert(que.begin() + position, people[i]);
          }
          return que;
      }
  };
  ```

  

  ### [补]：vector容器的实现方式

  ​	易知vector可以视为动态数组；

  ​	vector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的；

  ​	而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定和size相等；

  ​	当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1；

  ​	如图：

  ![](https://gitee.com/salinoia/image/raw/master/20201218185902217.png)

​	原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4；

​	那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存；

​	**注意图中底层数组的内存起始地址已经变了**；

​	使用vector来做insert的操作，此时大家可会发现，**虽然表面上复杂度是O(n\^2)，但是其底层都不知道额外做了多少次全量拷贝了，所以算上vector的底层拷贝，整体时间复杂度可以认为是O(n\^2 + t × n)级别的，t是底层拷贝的次数**;

​	

​	所以这道题选择用链表而非vector的形式实现：

```cpp
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            //it迭代器在每一次循环中都在更新，所以必须使用新的que来存放数据，而不能使用原有的数组
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```

## 用最少数量的箭引爆气球

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

示例 1：

- 输入：points = [[10,16],[2,8],[1,6],[7,12]]
- 输出：2
- 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球

示例 2：

- 输入：points = [[1,2],[3,4],[5,6],[7,8]]
- 输出：4

示例 3：

- 输入：points = [[1,2],[2,3],[3,4],[4,5]]
- 输出：2

示例 4：

- 输入：points = [[1,2]]
- 输出：1

示例 5：

- 输入：points = [[2,3],[2,3]]
- 输出：1

提示：

- 0 <= points.length <= 10^4
- points[i].length == 2
- -2^31 <= xstart < xend <= 2^31 - 1

​	局部最优：尽量找区间重叠得多的区域，一支箭尽可能多射多个气球；整体最优：箭最少；

![](https://gitee.com/salinoia/image/raw/master/20201123101929791.png)

​	如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了，不需要移除元素；

```cpp
	static bool cmp(const vector<int>& a, const vector<int>& b){
        return a[0] < b[0];
    }
	int minArrows(vector<vector<int>>& ballons){
        if(ballons.size() == 0)	return 0;
        sort(ballons.begin(), ballons.end(), cmp);
        int res = 1;//非空至少需要一支箭
        for(int i = 1; i < ballons.size(); i++){
            if(ballons[i][0] > ballons[i - 1][1]){//气球i的左边界大于气球i-1的右边界
                res++;
            }
            else{//更新右边界
                ballons[i][1] = min(ballons[i - 1][1], ballons[i][1]);
            }
        }
        return res;
    }
```

